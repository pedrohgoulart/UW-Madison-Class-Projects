package edu.wisc.cs.sdn.vnet.sw;

import net.floodlightcontroller.packet.Ethernet;
import edu.wisc.cs.sdn.vnet.Device;
import edu.wisc.cs.sdn.vnet.DumpFile;
import edu.wisc.cs.sdn.vnet.Iface;

import java.sql.Timestamp;

/**
 * @author Aaron Gember-Jacobson
 */
class ForwardTable {
	long startTime;
	Iface ifaceName;

	public forwardTable(long time, Iface iface) {
		this.startTime = time;
		this.ifaceName = iface;
	}

	public long getTime() {
		return this.startTime;
	}

	public void setTime(long time) {
		this.startTime = time;
	}

	public Iface getIface() {
		return this.ifaceName;
	}
}

public class Switch extends Device {
	public static ConcurrentHashMap<MACAddress, ForwardTable> fTableMap;

	public setupForwardTable() {
		this.fTableMap = new ConcurrentHashMap<MACAddress, ForwardTable>();
	}

	/**
	 * Creates a router for a specific host.
	 * @param host hostname for the router
	 */
	public Switch(String host, DumpFile logfile) {
		super(host,logfile);
	}

	/**
	 * Handle an Ethernet packet received on a specific interface.
	 * @param etherPacket the Ethernet packet that was received
	 * @param inIface the interface on which the packet was received
	 */
	public void handlePacket (Ethernet etherPacket, Iface inIface) {
		System.out.println("*** -> Received packet: " +
			etherPacket.toString().replace("\n", "\n\t"));

		// Save start time to keep track of timeout
		startTime = new Timestamp(System.currentTimeMillis()).getTime();

		// Mac addresses and interface
		MACAddress srcMac = etherPacket.getSourceMAC();
		MACAddress destMac = etherPacket.getDestinationMAC();
		Map<String, Iface> packetOutIface = getIfaces();;

		// Check if srcMac and destMac are null
		if (srcMac == null) {
			System.out.println("Error: Source Mac Address is Null");
                        System.exit(1);
		} else if (destMac == null) {
			System.out.println("Error: Destination Mac Address is Null");
			System.exit(1);
		}

		// Check if destMac has timed out
		if (forwardTableTimes.containsKey(destMac) {
			packetOutIface = forwardTable.get(destMac);
		}

		if (packetOutIface != null) {
			// Forward packet to interface
			sendPacket(etherPacket, packetOutIface);

			// Update time in forwardTable
			forwardTableTimes.remove(srcMac);
			forwardTableTimes.put(srcMac, startTime);
		} else {
			// Broadcast packet
			Collection<Iface> Ifaces = interfaces.values().iterator();
			Iface currIFace;

			while (Ifaces.hasNext()) {
				currIface = Ifaces.next();
				if (currIface != inIface) {
					sendPacket(etherPacket, currIface);
				}
			}

			// Add interface to interface table
			forwardTable.put(srcMac, inIface);
			forwardTableTimes.put(srcMac, startTime);
		}
	}
}
